#!/bin/bash
#   author: Matus Hubinsky 
#   xlogin: xhubin04
#   date:   19.03.2023

export MOLE_RC=$HOME/.config/molerc

export POSIXLY_CORRECT=yes
export LC_NUMERIC=en_US.UTF-8
export LC_COLLATE=C

print_help() {
    echo "Usage: "
    echo "      mole [-h]"
    echo "      mole [FILTERS] [DIRECTORY]"
    echo " "
    echo "COMMANDS:"
    echo "      mole list [FILTERS] [DIRECTORY]     opens certain file"
    echo " "
    echo "FILTERS:"
    echo "      [-h]                                prints help"
    echo "      [-g GROUP1[,GROUP2[,...]]] FILE     add file to a GROUP"
    echo "      [-m] [FILTERS] [DIRECTORY]          opens the file thah was edited most frequently"
    echo "      [-a DATE] YYYY-MM-DD                lists all the files edited after certain date"
    echo "      [-b DATE] YYYY-MM-DD                lists all the files edited begore certain date"
}

error() {
    >&2 echo "error"
    exit 1
}

check() {
    head=$(dd bs=1 count=1 2>/dev/null; echo a)
    head=${head%a}
    if [ "x$head" != x"" ]; then
        { printf %s "$head"; cat; } | "$@"
    fi
}

most() {
    if [ -z "$FILTER" ]; then
        # Pokud byl zadán argument -m, tak skript vybere soubor, který byl pomocí skriptu otevřen (editován) nejčastěji.
        # Pokud bude při použití přepínače -m nalezeno více souborů se stejným maximálním počtem otevření, může mole vybrat kterýkoliv z nich.
        echo "najčastejšie"
        awk 'BEGIN{max < ++c[$0]} {max = c[$0]; line = $0} END{print}'
        # uniq -c | sort -bgr
    else 
        # Pokud bylo v daném adresáři editováno skriptem více souborů, vybere se soubor, který byl pomocí skriptu otevřen (editován) jako poslední.
        echo "posledný"
        awk 'END{print}'
    fi

    # Pokud nebyl v daném adresáři otevřen (editován) ještě žádný soubor, případně žádný soubor nevyhovuje zadaným filtrům, jedná se o chybu.
}

secret_log() {
    echo "secret log"
}

date_before() {
    awk -F '|' -v date="$DATE_BEFORE" '{if (FNR>1 && $3<date) print}'
}

date_after() {
    awk -F '|' -v date="$DATE_AFTER" '{if (FNR>1 && $3>date) print}'
}

DATE=$(date +%F_%H-%M-%S)
DATE_AFTER="0000-00-00"
DATE_BEFORE="9999-99-99" 
FILE=""
GROUP="-"
FILTER=""
DIRECTORY=""
COMMAND=""
OUTPUT=""

# check if utillity realpath is available
if ! [ -x "$(command -v realpath)" ]; then
    echo "<realpath> could not be found"
    exit 1
fi

# look for MOLE_RC, export MOLE_RC=$HOME/.config/molerc
if [ -n "$MOLE_RC" ]; then
    if [ ! -e "$MOLE_RC" ]; then
        touch "$MOLE_RC"
    fi
else
    echo "MOLE_RC can't be found"
    exit 1
fi

# kontrola či je niečo na stdin
[ ! -z $1 ] || exit 1
# kontrola či sa jedná o príkaz alebo otvorenie súbora
if [ $1 == "list" ] || [ $1 == "secret-log" ]; then
    COMMAND=$1
    echo "command: $COMMAND" 
    shift
else
    FILE=$1
    [ -n "$FILE" ] || error
    
    # look for EDITOR, VISUAL, vi
    if [ -e "EDITOR" ]; then
        EDITOR="EDITOR"
    elif [ -e "VISUAL" ]; then
        EDITOR="VISUAL"
    else
        EDITOR="vi"
    fi
    eval "$EDITOR" "$FILE"
fi

set -x
while getopts "g:a:b:mh" args 
do    
    case "${args}" in
        h)
            print_help
            exit 0
            ;;
        g)  
            # for i in $(echo "$group" | tr "," "\n")
            GROUP=${OPTARG}
            FILE=${OPTARG}
            echo "$FILE|$GROUP|$DATE" >> "$MOLE_RC"
            exit 0
            ;;
        m)
            DIRECTORY=${OPTARG}            
            # Pokud DIRECTORY odpovídá existujícímu adresáři, skript z daného adresáře vybere soubor, který má být otevřen.
            if [ -n "$DIRECTORY" ]; then
                :
                # echo "vonkajší"
            # Pokud nebyl zadán adresář, předpokládá se aktuální adresář.
            else
                :
                # echo "aktualny"
            fi
            ;;
        a)   
            DATE_AFTER=${OPTARG}
            if [[ ! "$DATE_AFTER" =~ ^[0-9]{4}-[0-1][0-9]-[0-3][0-9]$ ]]; then
                >&2 echo "Date $DATE_AFTER is not in YYYY-MM-DD format"
                exit 1
            fi
            ;;
        b)
            DATE_BEFORE=${OPTARG}
            if [[ ! "$DATE_BEFORE" =~ ^[0-9]{4}-[0-1][0-9]-[0-3][0-9]$ ]]; then
                >&2 echo "Date $DATE_AFTER is not in YYYY-MM-DD format"
                exit 1
            fi
            ;;
        *)
            echo "some weird args..."
            exit 1
            ;;
    esac
done

case "$COMMAND" in
    list)   
        cat $MOLE_RC | date_before | date_after | awk -F '|' '{print $1": "$2}' | sort -u | column -t -o " "
        # cat $MOLE_RC | most | sort -u | awk -F '|' '{print $1" "$2" "$3}'
        ;;
    secret-log)
        secret_log
        ;;
esac

exit 0